<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Echo.DataFlow</name>
    </assembly>
    <members>
        <member name="T:Echo.DataFlow.Analysis.CyclicDependencyException">
            <summary>
            Represents the exception that occurs when a cyclic dependency was detected in a data flow graph.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Analysis.CyclicDependencyException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Echo.DataFlow.Analysis.CyclicDependencyException"/> class.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Analysis.CyclicDependencyException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Echo.DataFlow.Analysis.CyclicDependencyException"/> class, with the specified message.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Echo.DataFlow.Analysis.CyclicDependencyException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Echo.DataFlow.Analysis.CyclicDependencyException"/> class, with the specified message
            and inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message.</param>
            <param name="innerException">The inner exception that was the cause of this exception.</param>
        </member>
        <member name="T:Echo.DataFlow.Analysis.DependencyCollection">
            <summary>
            Provides members for collecting data dependencies in a data flow graph.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Analysis.DependencyCollection.GetOrderedDependencies``1(Echo.DataFlow.DataFlowNode{``0})">
            <summary>
            Collects all dependency nodes recursively, and sorts them in a topological order such that the final collection
            of nodes can be executed sequentially.
            </summary>
            <param name="node">The node to find all dependencies for.</param>
            <typeparam name="T">The type of contents that each node contains.</typeparam>
            <returns>The topological ordering of all dependencies of the node.</returns>
            <exception cref="T:Echo.DataFlow.Analysis.CyclicDependencyException">Occurs when there is a cyclic dependency in the graph.</exception>
        </member>
        <member name="M:Echo.DataFlow.Analysis.DependencyCollection.GetOrderedDependencies``1(Echo.DataFlow.DataFlowNode{``0},Echo.DataFlow.Analysis.DependencyCollectionFlags)">
            <summary>
            Collects all dependency nodes recursively, and sorts them in a topological order such that the final collection
            of nodes can be executed sequentially.
            </summary>
            <param name="node">The node to find all dependencies for.</param>
            <param name="flags">Flags that influence the behaviour of the algorithm.</param>
            <typeparam name="T">The type of contents that each node contains.</typeparam>
            <returns>The topological ordering of all dependencies of the node.</returns>
            <exception cref="T:Echo.DataFlow.Analysis.CyclicDependencyException">Occurs when there is a cyclic dependency in the graph.</exception>
        </member>
        <member name="T:Echo.DataFlow.Analysis.DependencyCollectionFlags">
            <summary>
            Provides flags that influence the behaviour of the <see cref="T:Echo.DataFlow.Analysis.DependencyCollection"/> class.
            </summary>
        </member>
        <member name="F:Echo.DataFlow.Analysis.DependencyCollectionFlags.IncludeStackDependencies">
            <summary>
            Indicates stack dependency edges should be traversed during the collection.
            </summary>
        </member>
        <member name="F:Echo.DataFlow.Analysis.DependencyCollectionFlags.IncludeVariableDependencies">
            <summary>
            Indicates variable dependency edges should be traversed during the collection.
            </summary>
        </member>
        <member name="F:Echo.DataFlow.Analysis.DependencyCollectionFlags.IncludeAllDependencies">
            <summary>
            Indicates all edges should be traversed during the collection.
            </summary>
        </member>
        <member name="T:Echo.DataFlow.Collections.DataFlowNodeCollection`1">
            <summary>
            Represents a mutable collection of nodes present in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of data that is stored in each node.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Collections.DataFlowNodeCollection`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Item(System.Int64)">
            <summary>
            Gets a node by its identifier.
            </summary>
            <param name="id">The node identifier.</param>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Add(System.Int64,`0)">
            <summary>
            Creates and adds a new node to the collection of data flow nodes.
            </summary>
            <param name="id">The unique identifier of the node.</param>
            <param name="contents">The contents of the node.</param>
            <returns>The created node.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Add(Echo.DataFlow.DataFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.AddRange(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataFlowNode{`0}})">
            <summary>
            Adds a collection of nodes to the graph.
            </summary>
            <param name="items">The nodes to add.</param>
            <exception cref="T:System.ArgumentException">
            Occurs when at least one node in the provided collection is already added to another graph.
            </exception>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Contains(System.Int64)">
            <summary>
            Determines whether a node with a specific offset was added to the collection.
            </summary>
            <param name="offset">The offset to the node.</param>
            <returns><c>true</c> if there exists a node with the provided offset, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Contains(Echo.DataFlow.DataFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.CopyTo(Echo.DataFlow.DataFlowNode{`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Remove(System.Int64)">
            <summary>
            Removes a node by its offset.
            </summary>
            <param name="offset">The offset. of the node to remove.</param>
            <returns><c>true</c> if the collection contained a node with the provided offset., and the node was removed
            successfully, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.UpdateIndices">
            <summary>
            Synchronizes all offsets of each node with the underlying instructions.
            </summary>
            <exception cref="T:System.InvalidOperationException">Occurs when one or more nodes are in a state that new offsets
            cannot be determined. This includes duplicated offsets.</exception>
            <remarks>
            <para>
            Because updating offsets is a relatively expensive task, calls to this method should be delayed as much as
            possible.
            </para>
            <para>
            This method will invalidate any enumerators that are enumerating this collection of nodes.
            </para>
            </remarks>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Remove(Echo.DataFlow.DataFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.Collections.StackDependencyCollection`1">
            <summary>
            Represents a collection of dependencies allocated on a stack for a node in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of contents to put in each node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.#ctor(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Creates a new dependency collection for a node.
            </summary>
            <param name="owner">The owner node.</param>
        </member>
        <member name="P:Echo.DataFlow.Collections.StackDependencyCollection`1.EdgeCount">
            <summary>
            Gets the total number of edges that are stored in this dependency collection.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.SetCount(System.Int32)">
            <summary>
            Ensures the node has the provided amount of stack dependencies.
            </summary>
            <param name="count">The new amount of dependencies.</param>
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.InsertItem(System.Int32,Echo.DataFlow.StackDependency{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.SetItem(System.Int32,Echo.DataFlow.StackDependency{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.RemoveItem(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.ClearItems">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.GetEnumerator">
            <summary>
            Gets the enumerator for this stack dependency collection.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator">
            <summary>
            Represents an enumerator for a stack dependency collection.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator.#ctor(Echo.DataFlow.Collections.StackDependencyCollection{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator"/> structure.
            </summary>
            <param name="collection">The collection to enumerate.</param>
        </member>
        <member name="P:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.Collections.VariableDependencyCollection`1">
            <summary>
            Represents a collection of variables and their symbolic values that a node in a data flow graph depends on.
            </summary>
            <typeparam name="TContents">The type of contents to put in each node.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.Item(Echo.Core.Code.IVariable)">
            <summary>
            Gets or sets the variable dependency assigned to the variable.
            </summary>
            <param name="variable">The variable</param>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Remove(Echo.DataFlow.VariableDependency{`0})">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.EdgeCount">
            <summary>
            Gets the total number of edges that are stored in this dependency collection.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.TryGetDependency(Echo.Core.Code.IVariable,Echo.DataFlow.VariableDependency{`0}@)">
            <summary>
            Attempts to get the dependency assigned to the provided variable.
            </summary>
            <param name="variable">The variable.</param>
            <param name="dependency">When this function returns <c>true</c>, contains the dependency.</param>
            <returns><c>true</c> if the variable was registered as a dependency, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Add(Echo.DataFlow.VariableDependency{`0})">
            <summary>
            Adds a variable dependency to the node.
            </summary>
            <param name="dependency">The dependency to add.</param>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Contains(Echo.DataFlow.VariableDependency{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.ContainsVariable(Echo.Core.Code.IVariable)">
            <summary>
            Determines whether the provided variable is registered as a dependency.
            </summary>
            <param name="variable">The dependency.</param>
            <returns></returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.CopyTo(Echo.DataFlow.VariableDependency{`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Remove(Echo.Core.Code.IVariable)">
            <summary>
            Unregisters a variable as a dependency. 
            </summary>
            <param name="variable">The variable to unregister.</param>
            <returns><c>true</c> if the variable was registered before and is now unregistered, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.GetRegisteredVariables">
            <summary>
            Obtains a collection of variables that are registered in the dependency. 
            </summary>
            <returns>The variables.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.GetEnumerator">
            <summary>
            Obtains an enumerator that enumerates all recorded variable dependencies in this collection. 
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="T:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator">
            <summary>
            Represents an enumerator that enumerates all entries in a variable dependencies collection.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.#ctor(Echo.DataFlow.Collections.VariableDependencyCollection{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator"/> class.
            </summary>
            <param name="collection">The collection to enumerate.</param>
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.DataDependency`2">
            <summary>
            Provides a base for data dependencies of a node in a data flow graph, which is a set of one or more data flow
            nodes where the owner node might pull data from.
            </summary>
            <typeparam name="TSource">The type of data source that this dependency uses.</typeparam>
            <typeparam name="TContents">The type of contents to put in a data flow node.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.DataDependency`2.Count">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.DataDependency`2.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.DataDependency`2.HasKnownDataSources">
            <summary>
            Gets a value indicating whether the data dependency has any known data sources. 
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataDependency`2.Dependent">
            <summary>
            Gets the node that owns the dependency.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.System#Collections#Generic#ICollection{TSource}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Remove(Echo.DataFlow.DataFlowNode{`1})">
            <summary>
            Removes all data sources that are incident with the provided node.
            </summary>
            <param name="node">The node.</param>
            <returns><c>true</c> if at least one edge was removed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.GetEdges">
            <summary>
            Gets a collection of data flow edges that encode the stored data sources.
            </summary>
            <returns>The edges.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.GetNodes">
            <summary>
            Gets a collection of nodes that are possible data sources for the dependency.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Echo.DataFlow.DataDependencyType">
            <summary>
            Provides members for describing types of dependencies between nodes in a data flow graph.
            </summary>
        </member>
        <member name="F:Echo.DataFlow.DataDependencyType.Stack">
            <summary>
            Indicates the dependency is a stack dependency.
            </summary>
        </member>
        <member name="F:Echo.DataFlow.DataDependencyType.Variable">
            <summary>
            Indicates the dependency is a variable dependency.
            </summary>
        </member>
        <member name="T:Echo.DataFlow.DataFlowEdge`1">
            <summary>
            Represents an edge between two nodes in a data flow graph (DFG). The origin of the node represents the dependant,
            and the target of the node represents the dependency.
            </summary>
            <typeparam name="TContents">The type of information to store in each data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.DataFlowEdge`1.#ctor(Echo.DataFlow.DataFlowNode{`0},Echo.DataFlow.DataSource{`0})">
            <summary>
            Creates a new dependency edge between two nodes.
            </summary>
            <param name="dependent">The dependent node.</param>
            <param name="target">The dependency node.</param>
        </member>
        <member name="P:Echo.DataFlow.DataFlowEdge`1.Dependent">
            <summary>
            Gets node that depends on the data source. 
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowEdge`1.DataSource">
            <summary>
            Gets the data source this data flow edge points to.
            </summary>
        </member>
        <member name="T:Echo.DataFlow.DataFlowGraph`1">
            <summary>
            Represents a graph that encodes data dependencies between objects. An edge (A, B) indicates node A depends on
            the evaluation of node B.
            </summary>
            <typeparam name="TContents">The type of contents to store for each node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.DataFlowGraph`1.#ctor(Echo.Core.Code.IInstructionSetArchitecture{`0})">
            <summary>
            Creates a new data flow graph.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowGraph`1.Architecture">
            <summary>
            Gets the architecture of the instructions that are stored in the data flow graph.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowGraph`1.Nodes">
            <summary>
            Gets a collection of nodes that are present in the graph.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.DataFlowGraph`1.Echo#Core#Graphing#ISubGraph#GetNodes">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataFlowGraph`1.Echo#Core#Graphing#ISubGraph#GetSubGraphs">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataFlowGraph`1.GetEdges">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataFlowGraph`1.ToDotGraph(System.IO.TextWriter)">
            <summary>
            Serializes the data flow graph to the provided output text writer using the dot file format.
            </summary>
            <param name="writer">The output stream.</param>
            <remarks>
            To customize the look of the resulting dot file graph, use the <see cref="T:Echo.Core.Graphing.Serialization.Dot.DotWriter"/> class
            instead of this function.
            </remarks>
        </member>
        <member name="T:Echo.DataFlow.DataFlowNode`1">
            <summary>
            Represents a single node in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of contents to store in the node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.#ctor(System.Int64,`0)">
            <summary>
            Creates a new data flow graph node.
            </summary>
            <param name="id">A unique identifier for the node that can be used for indexing the node.</param>
            <param name="contents">The contents of the node.</param>
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.ParentGraph">
            <summary>
            Gets the data flow graph this node is a part of.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.Id">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.InDegree">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.OutDegree">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.IsExternal">
            <summary>
            Gets a value indicating whether the data flow node represents an external data source.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.Contents">
            <summary>
            Gets the contents of the node.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.StackDependencies">
            <summary>
            Gets a collection of values allocated on a stack that this node depends on.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.VariableDependencies">
            <summary>
            Gets a collection of values that are assigned to variables that this node depends on.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.GetIncomingEdges">
            <summary>
            Obtains a collection of edges that refer to dependent nodes.
            </summary>
            <returns>The edges.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.GetOutgoingEdges">
            <summary>
            Obtains a collection of edges encoding all the dependencies that this node has.
            </summary>
            <returns>The edges.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.GetDependants">
            <summary>
            Obtains a collection of nodes that depend on this node.
            </summary>
            <returns>The dependant nodes.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.Disconnect">
            <summary>
            Removes all incident edges (both incoming and outgoing edges) from the node, effectively isolating the node
            in the graph. 
            </summary>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.DataSource`1">
            <summary>
            Represents a data source in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of data stored in each data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.#ctor(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Creates a new data source.
            </summary>
            <param name="node">The node producing the data.</param>
        </member>
        <member name="P:Echo.DataFlow.DataSource`1.Node">
            <summary>
            Gets the data flow node that produced the data.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataSource`1.Type">
            <summary>
            Gets the type of data dependency that this data source encodes.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.Equals(Echo.DataFlow.DataSource{`0})">
            <summary>
            Determines whether the data sources are considered equal.
            </summary>
            <param name="other">The other data source.</param>
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.op_Equality(Echo.DataFlow.DataSource{`0},Echo.DataFlow.DataSource{`0})">
            <summary>
            Determines whether the data sources are considered equal.
            </summary>
            <param name="a">The first data source.</param>
            <param name="b">The second data source.</param>
            <returns><c>true</c> if they are considered equal, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.op_Inequality(Echo.DataFlow.DataSource{`0},Echo.DataFlow.DataSource{`0})">
            <summary>
            Determines whether the data sources are not considered equal.
            </summary>
            <param name="a">The first data source.</param>
            <param name="b">The second data source.</param>
            <returns><c>true</c> if they are not considered equal, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Echo.DataFlow.Emulation.SymbolicProgramState`1">
            <summary>
            Represents an immutable snapshot of a program state that is fully symbolic.  
            </summary>
            <typeparam name="T">The type of instructions.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicProgramState`1.Empty">
            <summary>
            Gets an empty program state.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.#ctor(System.Int64)">
            <summary>
            Creates a new empty program state, initialized at the provided program counter.
            </summary>
            <param name="programCounter">The initial program counter.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.#ctor(System.Int64,System.Collections.Immutable.ImmutableStack{Echo.DataFlow.Emulation.SymbolicValue{`0}})">
            <summary>
            Creates a new empty program state, initialized at the provided program counter.
            </summary>
            <param name="programCounter">The initial program counter.</param>
            <param name="stack">The initial stack state.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.#ctor(System.Int64,System.Collections.Immutable.ImmutableDictionary{Echo.Core.Code.IVariable,Echo.DataFlow.Emulation.SymbolicValue{`0}})">
            <summary>
            Creates a new empty program state, initialized at the provided program counter.
            </summary>
            <param name="programCounter">The initial program counter.</param>
            <param name="variables">The initial state of the variables.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.#ctor(System.Int64,System.Collections.Immutable.ImmutableStack{Echo.DataFlow.Emulation.SymbolicValue{`0}},System.Collections.Immutable.ImmutableDictionary{Echo.Core.Code.IVariable,Echo.DataFlow.Emulation.SymbolicValue{`0}})">
            <summary>
            Creates a new empty program state, initialized at the provided program counter.
            </summary>
            <param name="programCounter">The initial program counter.</param>
            <param name="stack">The initial stack state.</param>
            <param name="variables">The initial state of the variables.</param>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicProgramState`1.ProgramCounter">
            <summary>
            Gets the current value of the program counter that points to the instruction to be executed next.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicProgramState`1.Stack">
            <summary>
            Gets the current stack state of the program.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicProgramState`1.Variables">
            <summary>
            Gets the current variable state of the program.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.WithProgramCounter(System.Int64)">
            <summary>
            Copies the current state and moves the program counter of the copy to the provided address.
            </summary>
            <param name="programCounter">The new program counter.</param>
            <returns>The new program state.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.WithStack(System.Collections.Immutable.ImmutableStack{Echo.DataFlow.Emulation.SymbolicValue{`0}})">
            <summary>
            Copies the current state and replaces the stack state with a new one.
            </summary>
            <param name="stack">The new stack state.</param>
            <returns>The new program state.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.WithVariables(System.Collections.Immutable.ImmutableDictionary{Echo.Core.Code.IVariable,Echo.DataFlow.Emulation.SymbolicValue{`0}})">
            <summary>
            Copies the current state and replaces the variables state with a new one.
            </summary>
            <param name="variables">The new variables state.</param>
            <returns>The new program state.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.Push(Echo.DataFlow.Emulation.SymbolicValue{`0})">
            <summary>
            Copies the current state and pushes a new value onto the stack. 
            </summary>
            <param name="value">The new value.</param>
            <returns>The new program state.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.Pop(Echo.DataFlow.Emulation.SymbolicValue{`0}@)">
            <summary>
            Copies the current state and pops the top value from the stack. 
            </summary>
            <param name="value">The popped value.</param>
            <exception cref="T:Echo.Core.Emulation.StackImbalanceException">Occurs when the stack is empty.</exception>
            <returns>The new program state.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.MergeStates(Echo.DataFlow.Emulation.SymbolicProgramState{`0}@,Echo.DataFlow.Emulation.SymbolicProgramState{`0}@)">
            <summary>
            Merges two program states together, combining all data sources.
            </summary>
            <param name="otherState">The other program state to merge with.</param>
            <param name="newState">The newly created state.</param>
            <returns><c>true</c> if the state has changed, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentException">Occurs when the program counters do not match.</exception>
            <exception cref="T:Echo.Core.Emulation.StackImbalanceException">Occurs when the stack heights do not match.</exception>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.Emulation.SymbolicValue`1">
            <summary>
            Represents a symbolic value that resides in memory. 
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.#ctor">
            <summary>
            Creates a new symbolic value with no data sources.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.#ctor(Echo.DataFlow.DataSource{`0})">
            <summary>
            Creates a new symbolic value with a single data source.
            </summary>
            <param name="dataSource">The data source of the symbolic value.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.#ctor(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <summary>
            Creates a new symbolic value with the provided data sources.
            </summary>
            <param name="dataSources">The data sources of the symbolic value.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.#ctor(Echo.DataFlow.Emulation.SymbolicValue{`0},Echo.DataFlow.Emulation.SymbolicValue{`0})">
            <summary>
            Merges two data dependencies into one symbolic value.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicValue`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicValue`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicValue`1.IsKnown">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicValue`1.Size">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicValue`1.HasKnownDataSources">
            <summary>
            Gets a value indicating whether the data dependency has any known data sources. 
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.CreateStackValue(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Creates a new symbolic value referencing the first stack value produced by the provided node. 
            </summary>
            <param name="node">The node producing the value.</param>
            <returns>The symbolic value.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.CreateStackValue(Echo.DataFlow.DataFlowNode{`0},System.Int32)">
            <summary>
            Creates a new symbolic value referencing a stack value produced by the provided node. 
            </summary>
            <param name="node">The node producing the value.</param>
            <param name="slotIndex">The index of the stack value that was produced by the node.</param>
            <returns>The symbolic value.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.CreateVariableValue(Echo.DataFlow.DataFlowNode{`0},Echo.Core.Code.IVariable)">
            <summary>
            Creates a new symbolic value referencing a variable value assigned by the provided node. 
            </summary>
            <param name="node">The node assigning the value.</param>
            <param name="variable">The variable that was assigned a value.</param>
            <returns>The symbolic value.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.AsStackValue">
            <summary>
            Interprets the symbolic value as a collection of stack data sources.
            </summary>
            <returns>The stack data sources.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.AsVariableValue">
            <summary>
            Interprets the symbolic value as a collection of variable data sources.
            </summary>
            <returns>The variable data sources.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Copy">
            <summary>
            Creates an exact copy of the value.
            </summary>
            <returns>The copied value.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Add(Echo.DataFlow.DataSource{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.ExceptWith(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.IntersectWith(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.IsSubsetOf(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.IsSupersetOf(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Overlaps(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.SetEquals(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.UnionWith(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Contains(Echo.DataFlow.DataSource{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.CopyTo(Echo.DataFlow.DataSource{`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Remove(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Removes all data sources that are related to the specified node.
            </summary>
            <param name="node">The node to remove all data sources from.</param>
            <returns><c>true</c> if any data source was removed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Remove(Echo.DataFlow.DataSource{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.GetNodes">
            <summary>
            Gets a collection of nodes that were referenced by all data sources in this data dependency.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates over all data sources the data dependency defines.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="T:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator">
            <summary>
            Provides a mechanism for enumerating all data sources within a single symbolic value. 
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator.#ctor(Echo.DataFlow.Emulation.SymbolicValue{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator"/> structure.
            </summary>
            <param name="collection">The data dependency to enumerate the data sources for.</param>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.ExternalDataSourceNode`1">
            <summary>
            Represents an external data source in a data flow graph. 
            </summary>
            <typeparam name="TContents">The type of contents to store in the node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.ExternalDataSourceNode`1.#ctor(System.Int64,System.String)">
            <summary>
            Creates a new external data source.
            </summary>
            <param name="id">The unique identifier of the data source. This should be a negative number.</param>
            <param name="name">The display name of the external data source.</param>
        </member>
        <member name="M:Echo.DataFlow.ExternalDataSourceNode`1.#ctor(System.Int64,System.String,`0)">
            <summary>
            Creates a new external data source.
            </summary>
            <param name="id">The unique identifier of the data source. This should be a negative number.</param>
            <param name="name">The display name of the external data source.</param>
            <param name="contents">The contents of the data flow node.</param>
        </member>
        <member name="P:Echo.DataFlow.ExternalDataSourceNode`1.Name">
            <summary>
            Gets the name of the auxiliary data flow node.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.ExternalDataSourceNode`1.IsExternal">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.ExternalDataSourceNode`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1">
            <summary>
            Represents an adorner that styles edges in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of contents the nodes contain.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1.StackDependencyStyle">
            <summary>
            Gets or sets the edge style to use for edges representing stack dependencies.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1.IncludeStackEdgeLabels">
            <summary>
            Gets or sets a value indicating whether edges representing stack dependencies should be annotated
            with the stack slot index. 
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1.VariableDependencyStyle">
            <summary>
            Gets or sets the edge style to use for edges representing variable dependencies.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1.IncludeVariableEdgeLabels">
            <summary>
            Gets or sets a value indicating whether edges representing variable dependencies should be annotated
            with the variable that was referenced. 
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1.GetEdgeAttributes(Echo.Core.Graphing.IEdge,System.Int64,System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.Serialization.Dot.DataFlowNodeAdorner`1">
            <summary>
            Represents an adorner that adds the string representation of the embedded instructions to a node in a graph.
            </summary>
            <typeparam name="TContents">The type of instructions the nodes contain.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.Serialization.Dot.DataFlowNodeAdorner`1.NodeShape">
            <summary>
            Gets or sets the shape of the node.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Serialization.Dot.DataFlowNodeAdorner`1.GetNodeAttributes(Echo.Core.Graphing.INode,System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.StackDataSource`1">
            <summary>
            Represents a data source that refers to a stack value produced by a node in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of data stored in each data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.StackDataSource`1.#ctor(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Creates a new stack data source, referencing the first stack value produced by the provided node.
            </summary>
            <param name="node">The node producing the value.</param>
        </member>
        <member name="M:Echo.DataFlow.StackDataSource`1.#ctor(Echo.DataFlow.DataFlowNode{`0},System.Int32)">
            <summary>
            Creates a new stack data source, referencing a stack value produced by the provided node.
            </summary>
            <param name="node">The node producing the value.</param>
            <param name="slotIndex">The index of the stack value that was produced by the node.</param>
        </member>
        <member name="P:Echo.DataFlow.StackDataSource`1.SlotIndex">
            <summary>
            Gets a value indicating the stack slot index that was pushed by the instruction referenced in <see cref="P:Echo.DataFlow.DataSource`1.Node"/>.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.StackDataSource`1.Type">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.StackDataSource`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.StackDataSource`1.Equals(Echo.DataFlow.DataSource{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.StackDataSource`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.StackDependency`1">
            <summary>
            Represents a collection of data sources for a single stack slot dependency of a node.
            </summary>
            <typeparam name="TContents">The type of contents to put in a data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.StackDependency`1.Add(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Adds a data source to the dependency, referencing the first stack value produced by the provided node.
            </summary>
            <param name="node">The node producing the value.</param>
            <returns>The stack data source.</returns>
        </member>
        <member name="M:Echo.DataFlow.StackDependency`1.Add(Echo.DataFlow.DataFlowNode{`0},System.Int32)">
            <summary>
            Adds a data source to the dependency, referencing a stack value produced by the provided node.
            </summary>
            <param name="node">The node producing the value.</param>
            <param name="slotIndex">The index of the stack value that was produced by the node.</param>
            <returns>The stack data source.</returns>
        </member>
        <member name="T:Echo.DataFlow.VariableDataSource`1">
            <summary>
            Represents a data source that refers to a variable value assigned by a node in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of data stored in each data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.VariableDataSource`1.#ctor(Echo.DataFlow.DataFlowNode{`0},Echo.Core.Code.IVariable)">
            <summary>
            Creates a new variable data source referencing a variable value assigned by the provided node. 
            </summary>
            <param name="node">The node assigning the value.</param>
            <param name="variable">The variable that was assigned a value.</param>
        </member>
        <member name="P:Echo.DataFlow.VariableDataSource`1.Variable">
            <summary>
            Gets the variable that was referenced by <see cref="P:Echo.DataFlow.DataSource`1.Node"/>.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.VariableDataSource`1.Type">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.VariableDataSource`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.VariableDependency`1">
            <summary>
            Represents a collection of data sources for a single variable dependency of a node.
            </summary>
            <typeparam name="TContents">The type of contents to put in a data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.VariableDependency`1.#ctor(Echo.Core.Code.IVariable)">
            <summary>
            Creates a new variable dependency.
            </summary>
            <param name="variable">The variable to depend on.</param>
        </member>
        <member name="P:Echo.DataFlow.VariableDependency`1.Variable">
            <summary>
            Gets the variable that is depended upon.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.VariableDependency`1.Add(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Adds a data source to the dependency, referencing a variable value assigned by the provided node. 
            </summary>
            <param name="node">The node assigning the value.</param>
            <returns>The variable data source.</returns>
        </member>
    </members>
</doc>
